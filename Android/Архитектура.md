## Lifecycle

<p align="center"><img src="../images/lifecycle.png" alt="Activity Lifecycle"/></p>

> При повороте экрана `Activity` закрывается и пересоздается заново.

- `onRestart` - вызывается перед `onStart` только если приложение уже было остановлено с помощью `onStop`, но без
  `onDestroy`
- `Log.d(tag, message)` - запись в `DEBUG` консоли  `Logcat`. Тег помогает быстрее находить логи в `Logcat`
- `finish()` - метод для закрытия `Activity`
- `rememberSaveable` - сохраняет состояние при рекомпозиции и изменении конфигурации приложения, аналог `remember`,
  которая работает только при рекомпозиции.
- `LocalContext.current as Activity` - дает доступ к текущей `Activity`

## ViewModel

<p align="center"><img src="../images/architecture.png" alt="Architecture"/></p>

<p align="center"><img src="../images/UI-layer.png" alt="UI layer"/></p>

- `MutableLiveData` - вариант для обработки изменений в состоянии UI, вариант на замену `MutableState`. Чтобы
  использовать в `Jetpack Compose`, нужно вызывать функцию `observeAsState`. Плохо поддерживается с `Jetpack Compose`.
- `MutableStateFlow` - вариант для обработки изменений в состоянии UI, вариант на замену `MutableState`. Чтобы
  использовать в `Jetpack Compose`, нужно вызывать функцию `collectAsState`. Поддерживает реактивность и
  многопоточность.
- `ViewModel` - хранит состояние UI, которое не уничтожается при рекомпозиции и изменении конфигурации.
    - Вариант `rememberSaveable`, но может использоваться вне Compose, более общего назначения.
    - В качестве обсервера для данных относящихся только к UI лучше использовать `MutableState`, а для тех, что
      необходимо хранить - `MutableStateFlow`
    - Лучше использовать backing property для взаимодействия с такими объектами:
      ```kotlin
      private val _uiState = MutableStateFlow(GameUiState())
      val uiState: StateFlow<GameUiState> = _uiState.asStateFlow() // делает объект иммутабельным
      ```
    - Либо можно использовать приватный сеттер:
      ```kotlin
      var userGuess by mutableStateOf("")
      private set
      ```
    - Для использования в `Composable` функциях, нужно передавать в качестве параметра с дефолтным значением
      `viewModel()`. После этого создавать переменную с `by viewmodel.поле.collectAsState()`
    - На изменение состояния мы вызываем функцию `ViewModel` с новым состоянием в качестве параметра. Внутри мы можем
      обновить `MutableStateFlow` с помощью поля `value`, либо с помощью функции `update` (возможно только она вызывает
      рекомпозицию?)

## Навигация

- `NavController` (и его подкласс `NavHostController`) - отвечает за навигацию между экранами с помощью метода
  `navigate()`. Можно получить главный `NavHostController` с помощью `rememberNavController()`. При переходе к
  следующему пункту назначения он кладется в back stack, чтобы потом можно было вернуться к нему кнопкой возврата.
  Можно вернуться к предыдущему пункту назначения с помощью `popBackStack()` с атрибутами `route` и `inclusive`, если
  `true`, то снимает со стека также и сам `route`. Можно получить текущий экран в back stack с помощью
  `currentBackStackEntry` или `by navController.currentBackStackEntryAsState()`. А чтобы получить имя `route` можно
  вызвать у back stack поле `destination?.route`. Для проверки есть ли предыдущий экран можно использовать
  `previousBackStackEntry`. Можно вернуться на предыдущий экран с помощью `navigateUp()`.
- `NavGraph` - определяет `Composable` элементы в качестве пунктов назначения, к которым можно перейти
- `NavHost` - может выбирать `Composable` элемент в качестве текущего пункта назначения. Внутри вызываются
  функции `composable` с атрибутами `route` пунктов назначения. Атрибуты:
    - `navController`
    - `startDestination` - стартовый экран
- `Intent` - позволяет сделать запрос к операционной системе для перехода к другому приложению. Для этого требуется
  создать новую `Activity` с помощью `context.startActivity()` и передать в качестве параметра `Intent`, преобразованный
  в `Activity` с помощью `Intent.createChooser()`. Атрибуты:
    - Тип `Intent`-а - `ACTION_SEND`
    - Дополнительные данные - зависят от типа `Intent`-а, с помощью метода `putExtra()`
    - Тип дополнительных данных - `text/plain`, `image/*`, `video/*`
- `BackHandler` - необходим для обработки возвращения на предыдущий экран в случае, когда для навигации не используется
  `NavHost`

## Accessibility

`Breakpoint range` - разброс размеров экранов, который идентифицирует тип устройства (телефон, планшет)

<p align="center"><img src="../images/devices.png" alt="Devices"/></p>

- `WindowSizeClass` - класс отвечает за работу с экранами разных размеров
- `calculateWindowSizeClass()` - вычисляет размер окна
- `WindowWidthSizeClass` - ширина экрана, можно получить через поле `widthSizeClass` у `calculateWindowSizeClass()`

## Асинхронность

- `runBlocking()` - создает контекст для запуска корутин
- `lifecycleScope` и `viewModelScope` - встроенные функции для определения контекстов для запуска корутин в `Activity` и
  `ViewModel` соотвественно. Для запуска корутины у них нужно вызвать `launch`.
- `delay()` - задержка при выполнении корутины
- `launch()` - запуск корутины
- `async()` - запуск корутины, результат которой потом можно синхронно дождаться с помощью `await()`
- `coroutineScope()` - создает новую область выполнения для запуска корутин, которая ждет выполнения всех дочерних
  корутин
- `withContext()` - создает новый контекст, все запущенное внутри будет его иметь, но не ждет выполнения всех дочерних
  корутин
  > Dispatchers - Main, IO, Default

- `runTest()` - используется для тестирования корутин
  > Внутри тестов `delay` не работают
- `advanceTimeBy()` - добавить времени к текущему времени
- `runCurrent()` - выполняет все задачи, оставшиеся в текущий момент вреемени

## Retrofit

Для получения доступа к интернету нужно получить `permission` с помощью (добавляется перед `<application>`):
`<uses-permission android:name="android.permission.INTERNET" />`

Создается с помощью:

```kotlin
Retrofit.Builder()
    .addConverterFactory(FACTORY)
    .baseUrl(URL)
    .build()
```

Вместо FACTORY:

- `ScalarsConverterFactory` - для отображения `JSON` в виде `String`
- `Json.asConverterFactory("application/json".toMediaType()` - для преобразования `JSON` в объект. Объект нужно снабдить
  аннотацией `@Serializable`. Если имя поля отличается от имени в `JSON`, то нужно добавить `@SerialName(JSON-имя)` на
  поле.

Создается интерфейс, в котором описываются все `suspend` методы с аннотациями в виде метода HTTP и пути (`@GET("url")`).

После чего создается сервис с помощью `retrofit.create(интерфейс)`, у которого можно вызывать методы и получить данные.