### Общее

#### Циклы

- for (элемент in коллекция)
- for (элемент in 0..коллекция.lastIndex) - включая оба индекса
- for (элемент in коллекция.lastIndex downTo 0 step 2) - включая оба индекса
- for (индекс in коллекция.indices)
- for ((index, value) in коллекция.withIndex())

#### Полезные функции

- maxOf(2 или 3 значения)

#### Строки

- String
  - length
  - startsWith(префикс, отступ, игнор_кейса)
  - endsWith(суффикс, игнор_кейса)
  - substring(1..2) (с включением 2); substring(1, 2) (без включения 2); substring(1) (только старт)
  - isNotEmpty()
  - toCharArray()
- StringBuilder()
  - append("abc")
  - append("abc", начало, конец) (без включения конца)

#### Массивы

- IntArray(размер).toTypedArray() = Array<Int>(размер) { создание каждого элемента, где it номер индекса }

#### Коллекции

- arrayOf().size, mutableListOf().size
- MutableList(размер) { создание каждого элемента, где it номер индекса }

### Строки

1. Соединить две строки через символ - цикл пока хоть один итератор меньше длины одной из строк
2. Одна из строк полностью состоит из копий другой, нужно найти строку, которая так входит в обе -
алгоритм наибольшего общего делителя, либо вычитать из большей строки меньшую, пока они не равны (можно вычитать их длины)
3. Перевернуть гласные в строке - идем по строке с двух сторон одновременно и меняем места гласные
4. Перевернуть слова в строке - идем с конца строки, держим указатель на последний пробел, если встречаем пробел,
который дальше указателя на 1, добавляем в итоговую строку вырезанную строку с помощью append(); отдельно обрабатываем первое слово

### Массивы

1. Набор конфет у детей, вернуть массив, что если дать i ребенку набор доп конфет, то у него их будет максимальное число
среди всех - найти максимальное текущее количество, а потом пробежать и посмотреть какие дети будет с доп. конфетами максимальными
2. Проверить можно ли посадить n цветов в массив на пустые места через 1 - обычный цикл и сложное условие, которое учитывает,
что по бокам пусто
3. 