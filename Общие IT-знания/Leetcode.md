### Общее

#### Циклы

- for (элемент in коллекция)
- for (элемент in 0..коллекция.lastIndex) - включая оба индекса
- for (элемент in коллекция.lastIndex downTo 0 step 2) - включая оба индекса
- for (индекс in коллекция.indices)
- for ((index, value) in коллекция.withIndex())

#### Полезные функции

- Int.MAX_VALUE и Int.MIN_VALUE
- 5.digitToChar()
- maxOf(2 или 3 значения)

#### Строки

- String
  - length
  - startsWith(префикс, отступ, игнор_кейса)
  - endsWith(суффикс, игнор_кейса)
  - substring(1..2) (с включением 2); substring(1, 2) (без включения 2); substring(1) (только старт)
  - isNotEmpty()
  - toCharArray()
- StringBuilder() или buildString { где this - StringBUilder() }
  - append("abc")
  - append("abc", начало, конец) (без включения конца)


#### Массивы

- IntArray(5).contentEquals(IntArray(5))
- mutableListOf().toString() = arrayOf().contentToString()
- IntArray(размер).toTypedArray() = Array<Int>(размер) { создание каждого элемента, где it номер индекса }
- Array(размер) { IntArray(размер) } - двумерный массив

#### Коллекции

- ArrayDeque<Int>()
- hashMapOf<Int, Int>()
  - getOrDefault(элемент, знач_по_умолч)
  - getOrPut(элемент) { вычисление добавл. значения }
  - merge(элемент, знач) { действие если знач существует a, b -> a + b }
  - remove(ключ)
  - replace(ключ, старое_знач, новое_знач) - заменяет старое значение, если оно есть, на новое
- PriorityQueue<Int>() - по умолчанию (по увеличению)
  - PriorityQueue<Int> { o1, o2 -> o2 - o1 } - по уменьшению
  - PriorityQueue(Comparator<Тип> { ... }.thenComparing { ... }) - сложный компаратор


- arrayOf().size, mutableListOf().size
- forEach { it в качестве элемента }
- reverse() - переворачивает саму коллекцию, reversed() - возвращает перевернутый вариант
- MutableList(размер) { создание каждого элемента, где it номер индекса }

#### Бинарные операции

- 1 shl 3 - сдвиг влево на 3 бита
- or - побитовое или; and - побитовое и
- xor - исключающее или

### Строки

#### Легкие
1. Соединить две строки через символ - цикл пока хоть один итератор меньше длины одной из строк
2. Одна из строк полностью состоит из копий другой, нужно найти строку, которая так входит в обе -
алгоритм наибольшего общего делителя, либо вычитать из большей строки меньшую, пока они не равны (можно вычитать их длины)
3. Перевернуть гласные в строке - идем по строке с двух сторон одновременно и меняем места гласные

#### Средние
1. Перевернуть слова в строке - идем с конца строки, держим указатель на последний пробел, если встречаем пробел,
который дальше указателя на 1, добавляем в итоговую строку вырезанную строку с помощью append(); отдельно обрабатываем первое слово
2. Массив букв char, нужно соединить повторяющиеся буквы ('a', 'a', 'a' в 'a', '3') - идем по массиву, запоминая текущую
позицию для записи и количество повторенной текущей буквы, и записываем при смене буквы

### Массивы

#### Легкие
1. Набор конфет у детей, вернуть массив, что если дать i ребенку набор доп конфет, то у него их будет максимальное число
среди всех - найти максимальное текущее количество, а потом пробежать и посмотреть какие дети будет с доп. конфетами максимальными
2. Проверить можно ли посадить n цветов в массив на пустые места через 1 - обычный цикл и сложное условие, которое учитывает,
что по бокам пусто

#### Средние
1. Вернуть массив чисел, где i число является переменожением чисел из массива, кроме i-го - проходим слева направо,
а потом справа налево, переменожая элементы
2. Проверить есть ли в массиве тройка значений, которые идут по возрастанию - проходим по массиву, внутри условие:
если новое значение меньше минимального, перезаписываем, если нет, то проверяем новое значение меньше среднего и т.д.

### Указатели

#### Легкие
1. Переместить все нули в конец массива - запоминаем позицию записи, и записываем ненулевые элементы проходя по массиву,
остальное заполняем нулями
2. Проверить, что одна строка входит в другую ("ace" в "abcde") - держим указатель на вторую строку, пока идем по первой,
двигаем указатель если символы совпали, проверяем стоит ли указатель на конец строки

#### Средние
1. Найти наибольшее количество воды в контейнере с расположенными внутри на разном расстоянии вертикальными столбами разной высоты -
левый и правый указатели, идем пока они не встретятся, если левый столб меньше, чем правый, то двигаем левый указатель, иначе правый.

### Двигающееся окно

#### Легкие
1. Найти максимальную сумму k подряд идущих чисел в массиве - считаем сумму первых k чисел, потом идем по массиву с k элемента,
и на каждом шаге прибавляем i число к сумме и отнимаем i-k число

#### Средние
1. Найти максимальное количество гласных в подстроке длины k - идем по массиву, если i элемент гласная, то добавляем к счетчику,
если i >= k, то дополнительно проверяем i-k элемент, и если он гласная, то вычитаем из счетчика
2. Найти максимальное количество подряд идущих единиц в массиве, если можно перевернуть максимум k нулей - делаем левый указатель, 
идем по массиву, считаем нули, если количество нулей становится больше k, идем от левого указателя, пока > k вычитаем все нули
3. Найти максимальное количество подряд идущих единиц в массиве, при удалении одного элемента из массива - аналогично 2, только k = 1,
и из ответа вычитаем 1, так как элемент удаляется.

### Префиксная сумма

#### Легкие
1. Найти индекс в массиве, чтобы суммы элементов справа и слева от него были равны - сначала проходим по массиву и ищем правую сумму,
проходим еще раз и на каждом шаге вычитаем из парвой суммы и добавляем к левой текущей элемент, если суммы равны, то выходим.

### HashMap / HashSet

#### Легкие
1. Найти разницу двух массивов (в каждом из новых должны быть только уникальные элементы, которых нет в другом) - 
приводим к Set, а потом вычитаем друг из друга.
2. Проверить что в массиве каждое значение повторяется уникальное количество раз - делаем мапу число-количество повторений,
а потом добавляем в set для проверки уникальности

#### Средние
1. Проверить что 2 строки похожи (получены друг из друга с помощью - обмена места 2 любых символов или превращение одного
символа в другой и наоборот) - проверяем равенство длин; создаем boolean массивы с длиной 26, и сохраняем наличие каждой
буквы в слове; создаем массивы с длиной 26, и сохраняем количество каждой буквы в словах; проверяем что в словах одни и те же буквы;
проверяем что набор количества букв одинаков.
2. Найти количество одинаковых столбцов и строк в матрице - создаем мапу (строка матрицы превращенная в строку, количество повторений),
обходим строки матрицы, обходим столбцы матрицы, создавая строки и проверяя мапу

### Стек

### Очередь

### Куча
